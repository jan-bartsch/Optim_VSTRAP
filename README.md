
# LARA  - _A Monte Car**L**o framework for optim**A**l cont**R**ol of plasm**A**_

The program solves optimal control problems governed by the non-linear kinetic equations including external forces and a collision term in a Monte Carlo framwork.

## Dependencies and required libraries
The code was optimized for Ubuntu 18.04 LTS. Before downloading the dependencies, make sure that Ubuntu is up-to-date  using ```sudo apt-get update``` and ```sudo apt-get upgrade```.

To use the optimizer, ```vstrap``` must be installed on the machine.

Before compiling the code the following dependencies and libraries must be installed:
+ [Armadillo](http://arma.sourceforge.net/docs.html) (this includes lapacke and blas): install using 
```sudo apt install liblapack-dev libblas-dev libarmadillo-dev```
+ openMP: install using 
```sudo apt install libomp-dev```
+ boost: install using 
```sudo apt install boost-dev```
+ build-essentials: install using
+ ```sudo apt-get install build-essential```
+ cmake: install using 
```sudo apt install cmake```

For **optional** postprocessing ```python3``` should be installed including the packages
+ argparse
+ pyplot from matplotlib
+ tikzplotlib
+ numpy 
+ math
+ pandas

The packages can be installed using the following commands
```sh
sudo apt install python3-pip -y
pip3 install matplotlib tikzplotlib pandas numpy
```


## Problem specifications

In the file _Optim_input.xml_ it is possible to specify the parameters used by the program.
View the comments in te file to get information about the purpose of each parameter.
The file ```src/controller/optim_controller.cpp``` is the core of the optimization.

## Structure of the code
The source code is structured in five categories:
+ **src/controller**: 	contains auxiliary subroutines like generating of probability density functions (pdf) and controller for input/output 
+ **src/io**: 		contains methods for solving the linear kinetic and adjoint linear kinetic problem
+ **src/logger**: 	core of optimization methods; contains important ncg subroutines and armijo-linesearch as well as functions providing the value of the functional and building the gradient
+ **src/objects**: 	contains python files for visualizing the results of the program
+ **src/optimization**:

The program has four more plugins:
+ **data**: Here, several test-cases are specified
+ **optim-vstrap-toolset**: Imporant plugin for the connection between vstrap and the optimizer
+ **pprc**: Files for post-processing (python)
+ **test**: gtest files

## Compile and run the program
After speficying the parameters, it is possible to compile the code and start the program with the following commands executed in the directory containing the ```MOCOKI``` folder.
```sh
mkdir build-Optim && cd build-Optim
cmake ../Optim_VSTRAP
make
./Optim_VSTRAP_CMAKE <path/to/>Optim_input.xml
```
## Post-processing
There are ```python``` files to visualize the results of the MOCOKI code.
Assuming the build directory ```build-Optim``` is at the same directory level as the ```Optim_VSTRAP``` folder, the following commands executed from the ```pprc``` folder can be used to visualize data generated by the code.

The following command takes files containing data about development of the value of functional, norm of gradient, norm of control and stepsize during the optimization process and plots these.
```sh
python3 visualize_control.py ../../data/box_shifting_CSSC/interpolated_control_field.xml ../../data/global/box_coarse_512.xml
```

The following command gives plots the control in the current iteration. One has to call the functional specifying the current control and the discretization of the physical domain.
```sh
python3 post_processing_convergence.py ../../../build-Optim/src/results/ 
```

## Using the dockerized version - UNDER CONSTRUCTION
It is possible to install a docker containing all the needed libraries and dependencies using the following commands executed in the folder in which the ```mocoki-image.tar``` file is located.
```sh
sudo docker load < mocoki-image.tar #loads image
sudo docker run --name container_mocoki -it mocoki #creates and starts container named 'container_mocoki' using the mocoki:latest image
```
After exiting the container, it can be started again using the command
```sh
sudo docker container start -ai container_mocoki

Inside the container go inside the ```MOCOKI``` folder and run
```sh
sh setup_cmake.sh
```

This will execute the current version of the code.

You can also change the code outside the docker container and copy it into and from the container using the commands
```sh
sudo docker cp MOCOKI/ container_mocoki:MOCOKI #copy inside the container
sudo docker cp container_mocoki:build-MOCOKI build-MOCOKI-v08 #copy build folder from container to local machine
```
The ```sudo``` command may be discarded inside docker.
